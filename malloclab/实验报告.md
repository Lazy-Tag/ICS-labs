# 实验报告

[TOC]

## 实验思路与数据结构的选用

### 实验主体框架（四个主要函数的实现）

本实验要求管理一个不超过20MB的内存，不使用显时数据结构、全局变量和堆区空间，实现动态内存的分配与管理。为了更好地管理空闲块，在主体框架沿用隐式链表实现，其中findFit函数我选用best-fit，并用红黑树进行加速查询。

### 内存管理数据结构

在第一版的算法中，我选用隐式链表对空间进行管理。我对每一个分配块与空闲块设置head块foot块。

#### 隐式链表定义宏

```c
#define PageSize (1 << 10) // 定义扩展每次分配内存
#define MinimumBlock 32 //最小块大小
#define WSize 4 //单字大小
#define DSize 8 //双字大小
#define Alignment 8 //对齐
#define Align(size) (((size) + (Alignment-1)) & ~0x7) //round-up
#define Read(x) (*(unsigned *)(x)) //读内存
#define Write(x, v) (*(unsigned *)(x) = (v)) //写内存
#define Length(x) (Read(x) & ~0x7) //块的长度
#define IsUsed(x) (Read(x) & 1) //块是否被分配
#define GetHead(x) ((char*) (x) - WSize) //获取头部块
#define GetFoot(x) ((char*) (x) + Length(GetHead(x)) - DSize) //获取尾部块
#define Next(x) ((char*) (x) + Length((char*) (x) - WSize)) //下一个块
#define Prev(x) ((char*) (x) - Length((char*) (x) - DSize)) //上一个块
```

#### 辅助函数

```C
static void *extend(size_t size); //扩展堆的大小

static void *findFit(Node u, size_t size); //找到合适块

void *place(void *ptr, int size); //对空闲块进行分割

static void *coalesce(void *bp); // 对空闲块进行合并
```

在最初的实现中，我findFit实现为First-Fit，后优化为Next-Fit，得分分别为65/100， 83/100。

### 空闲块管理数据结构

因为Best-Fit可以尽可能地减少内部碎片，但因为需要的全局链表的块进行遍历，吞吐量较低。所以我考虑使用红黑树对空闲块进行管理。首先我将存储整棵树的根节点放在startptr位置，即堆开头的位置，之后我将整个数据结构的实现定义在空闲块的内部，利用尚未分配的空间。为了正确实现数据结构，我将最小快的大小设置为32，并把空闲块的结构定义为如下形式：

```c
-----------------------------------------------------------------------------------------------------------------------------
|        Head         |         LC         |        RC        |         Parent        |     ...     |         Foot        |
-----------------------------------------------------------------------------------------------------------------------------
Head: 隐式链表的头部块，大小为4B
--  高30bit为块的长度，表示为块大小8bit对齐
--  中间一位表示该节点时红色节点还是黑色检点
-- 	低一位为隐式链表中的Valid位，表示为该节点是否空闲
LC: RBT的左儿子，大小为8bit
RC: RBT的右儿子，大小为8bit
Parent: RBT的父节点，大小为8bit
Foot: 隐式链表的尾部块，大小为4B
```

通过上图可知，最小块的大小为32bit即4B。

#### 红黑树定义宏

```c
// BST定义宏
#define Parent(x) (*(Node*)(x))
#define LC(x) (*(Node*)(x + DSize))
#define RC(x) (*(Node*)(x + 2 * DSize))
#define IsRoot(x) !Parent(x)
#define IsLChild(x) (Parent(x) && ((x) == LC(Parent(x))))
#define IsRChild(x) (Parent(x) && ((x) == RC(Parent(x))))
#define FromParentTo(x) (IsRoot(x)? root : (IsLChild(x)? &LC(Parent(x)) : &RC(Parent(x))))

// Red-Black Tree定义宏
#define Black 0
#define Red 1
#define Get(x) (*(int*) (x))
#define Color(x) ((x)? (Get(GetHead(x)) & 0x2) >> 1 : 0)
#define SetColor(x, v) ((x) ? ((v)? (Get(GetHead(x)) |= 0x2) : (Get(GetHead(x)) &= ~0x2)) : (x))
```

#### 红黑树定义函数

```C
// Red-Black Tree内部函数
static int cmp(Node a, Node b);

static Node getNext(Node u);

static void swap(Node *a, Node *b);

static void swapNode(Node a, Node b);

static void takeOff(Node u);

static void insert(Address address);

static void delete(Address address);

static Node rotateAt(Node u);

static Node connect34(Node a, Node b, Node c, Node t0, Node t1, Node t2, Node t3);

static void solveDoubleRed(Node x);

static void solveDoubleBlack(Node r);

static void print(Node u);

static int traverse(Node u);
```

在第二版实现中，得分为91/100。

## 实验优化

### 减少分配块的最小块大小

我发现只有空闲块需要存储红红黑树中的数据结构。因此，插入块的最小块大小可以小于32。为了实现8bit对齐，我将插入块的最小值设置为16，当存在空闲块的大小大于等于32时，我将其作为一个节点插入红黑树。

### 优化块分配大小

我发现在binary测试点中存在大量分配碎片快导致在链表中出现大量碎片块无法合并，使得出现空间的大量浪费。因此，我将接近于2的整数次幂的分配块round-up，减少内部碎片块无法合并的数量。

### 优化Realloc实现

我发现用原始的方法实现realloc伴随大量重新分配。因此，我对需要realloc的块进行检查，若存在Next块为空且Next块的大小大于需要再分配的大小，我将Next进行分割后与原块进行合并，之后返回原块的地址。若原块处于隐式链表的末端，则分配相应长度的空间与原块合并，否则重新分配空间并memcpy。

### 优化分割空闲块的方式

我发现Realloc对原块时候存在足够大的Next块的空间敏感，因此，每次分配新块时，优先从新块的尾部开始分配，以次尽可能减少memcpy的次数。

### 优化每次扩大空间大小

我发现越细粒度的空间分配可以带来更好的内存利用率，因此我权衡Kops和内存分配粒度，将每次扩大空间的大小从4KB调整为1KB。同时通过观察数据，我发现不同空间大小的分配对扩大空间的大小表现不同，为此我加入相应特判。

## 实验结果

最终得分：98/100

![image-20230422163436808](https://s2.loli.net/2023/04/22/JdLcyXEbFPhTKHw.png)

-